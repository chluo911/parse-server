{"version":3,"sources":["../src/Utils.js"],"names":["path","require","fs","promises","Utils","getLocalizedPath","defaultPath","locale","file","basename","basePath","dirname","localePath","join","localeFileExists","fileExists","subdir","language","split","languagePath","languageFileExists","access","e","isPath","s","test","flattenObject","obj","parentKey","delimiter","result","key","Object","prototype","hasOwnProperty","call","newKey","isPromise","object","Promise","getObjectKeyPermutations","index","current","results","keys","values","value","nextIndex","length","assign","push","validateParams","params","types","type","isOptional","o","param","v","t","module","exports"],"mappings":"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","sourcesContent":["/**\n * utils.js\n * @file General purpose utilities\n * @description General purpose utilities.\n */\n\nconst path = require('path');\nconst fs = require('fs').promises;\n\n/**\n * The general purpose utilities.\n */\nclass Utils {\n  /**\n   * @function getLocalizedPath\n   * @description Returns a localized file path accoring to the locale.\n   *\n   * Localized files are searched in subfolders of a given path, e.g.\n   *\n   * root/\n   * ├── base/                    // base path to files\n   * │   ├── example.html         // default file\n   * │   └── de/                  // de language folder\n   * │   │   └── example.html     // de localized file\n   * │   └── de-AT/               // de-AT locale folder\n   * │   │   └── example.html     // de-AT localized file\n   *\n   * Files are matched with the locale in the following order:\n   * 1. Locale match, e.g. locale `de-AT` matches file in folder `de-AT`.\n   * 2. Language match, e.g. locale `de-AT` matches file in folder `de`.\n   * 3. Default; file in base folder is returned.\n   *\n   * @param {String} defaultPath The absolute file path, which is also\n   * the default path returned if localization is not available.\n   * @param {String} locale The locale.\n   * @returns {Promise<Object>} The object contains:\n   * - `path`: The path to the localized file, or the original path if\n   *   localization is not available.\n   * - `subdir`: The subdirectory of the localized file, or undefined if\n   *   there is no matching localized file.\n   */\n  static async getLocalizedPath(defaultPath, locale) {\n    // Get file name and paths\n    const file = path.basename(defaultPath);\n    const basePath = path.dirname(defaultPath);\n\n    // If locale is not set return default file\n    if (!locale) {\n      return { path: defaultPath };\n    }\n\n    // Check file for locale exists\n    const localePath = path.join(basePath, locale, file);\n    const localeFileExists = await Utils.fileExists(localePath);\n\n    // If file for locale exists return file\n    if (localeFileExists) {\n      return { path: localePath, subdir: locale };\n    }\n\n    // Check file for language exists\n    const language = locale.split('-')[0];\n    const languagePath = path.join(basePath, language, file);\n    const languageFileExists = await Utils.fileExists(languagePath);\n\n    // If file for language exists return file\n    if (languageFileExists) {\n      return { path: languagePath, subdir: language };\n    }\n\n    // Return default file\n    return { path: defaultPath };\n  }\n\n  /**\n   * @function fileExists\n   * @description Checks whether a file exists.\n   * @param {String} path The file path.\n   * @returns {Promise<Boolean>} Is true if the file can be accessed, false otherwise.\n   */\n  static async fileExists(path) {\n    try {\n      await fs.access(path);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * @function isPath\n   * @description Evaluates whether a string is a file path (as opposed to a URL for example).\n   * @param {String} s The string to evaluate.\n   * @returns {Boolean} Returns true if the evaluated string is a path.\n   */\n  static isPath(s) {\n    return /(^\\/)|(^\\.\\/)|(^\\.\\.\\/)/.test(s);\n  }\n\n  /**\n   * Flattens an object and crates new keys with custom delimiters.\n   * @param {Object} obj The object to flatten.\n   * @param {String} [delimiter='.'] The delimiter of the newly generated keys.\n   * @param {Object} result\n   * @returns {Object} The flattened object.\n   **/\n  static flattenObject(obj, parentKey, delimiter = '.', result = {}) {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const newKey = parentKey ? parentKey + delimiter + key : key;\n\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\n          this.flattenObject(obj[key], newKey, delimiter, result);\n        } else {\n          result[newKey] = obj[key];\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether an object is a Promise.\n   * @param {any} object The object to validate.\n   * @returns {Boolean} Returns true if the object is a promise.\n   */\n  static isPromise(object) {\n    return object instanceof Promise;\n  }\n\n  /**\n   * Creates an object with all permutations of the original keys.\n   * For example, this definition:\n   * ```\n   * {\n   *   a: [true, false],\n   *   b: [1, 2],\n   *   c: ['x']\n   * }\n   * ```\n   * permutates to:\n   * ```\n   * [\n   *   { a: true, b: 1, c: 'x' },\n   *   { a: true, b: 2, c: 'x' },\n   *   { a: false, b: 1, c: 'x' },\n   *   { a: false, b: 2, c: 'x' }\n   * ]\n   * ```\n   * @param {Object} object The object to permutate.\n   * @param {Integer} [index=0] The current key index.\n   * @param {Object} [current={}] The current result entry being composed.\n   * @param {Array} [results=[]] The resulting array of permutations.\n   */\n  static getObjectKeyPermutations(object, index = 0, current = {}, results = []) {\n    const keys = Object.keys(object);\n    const key = keys[index];\n    const values = object[key];\n\n    for (const value of values) {\n      current[key] = value;\n      const nextIndex = index + 1;\n\n      if (nextIndex < keys.length) {\n        Utils.getObjectKeyPermutations(object, nextIndex, current, results);\n      } else {\n        const result = Object.assign({}, current);\n        results.push(result);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Validates parameters and throws if a parameter is invalid.\n   * Example parameter types syntax:\n   * ```\n   * {\n   *   parameterName: {\n   *      t: 'boolean',\n   *      v: isBoolean,\n   *      o: true\n   *   },\n   *   ...\n   * }\n   * ```\n   * @param {Object} params The parameters to validate.\n   * @param {Array<Object>} types The parameter types used for validation.\n   * @param {Object} types.t The parameter type; used for error message, not for validation.\n   * @param {Object} types.v The function to validate the parameter value.\n   * @param {Boolean} [types.o=false] Is true if the parameter is optional.\n   */\n  static validateParams(params, types) {\n    for (const key of Object.keys(params)) {\n      const type = types[key];\n      const isOptional = !!type.o;\n      const param = params[key];\n      if (!(isOptional && param == null) && !type.v(param)) {\n        throw `Invalid parameter ${key} must be of type ${type.t} but is ${typeof param}`;\n      }\n    }\n  }\n}\n\nmodule.exports = Utils;\n"]}