{"version":3,"sources":["../../src/Routers/SchemasRouter.js"],"names":["Parse","require","SchemaController","classNameMismatchResponse","bodyClass","pathClass","Error","INVALID_CLASS_NAME","getAllSchemas","req","config","database","loadSchema","clearCache","then","schemaController","getAllClasses","schemas","response","results","getOneSchema","className","params","schema","catch","error","undefined","INTERNAL_SERVER_ERROR","checkIfDefinedSchemasIsUsed","lockSchemas","OPERATION_FORBIDDEN","internalCreateSchema","body","controller","addClassIfNotExists","fields","classLevelPermissions","indexes","internalUpdateSchema","updateClass","createSchema","auth","isReadOnly","path","modifySchema","deleteSchema","classNameIsValid","invalidClassNameMessage","SchemasRouter","PromiseRouter","mountRoutes","route","middleware","promiseEnforceMasterKeyAccess"],"mappings":";;;;;;;AAKA;;AACA;;;;;;;;AANA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,YAAD,CAAP,CAAsBD,KAAlC;AAAA,IACEE,gBAAgB,GAAGD,OAAO,CAAC,iCAAD,CAD5B;;AAMA,SAASE,yBAAT,CAAmCC,SAAnC,EAA8CC,SAA9C,EAAyD;AACvD,QAAM,IAAIL,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYC,kBADR,EAEH,+BAA8BH,SAAU,QAAOC,SAAU,GAFtD,CAAN;AAID;;AAED,SAASG,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,SAAOA,GAAG,CAACC,MAAJ,CAAWC,QAAX,CACJC,UADI,CACO;AAAEC,IAAAA,UAAU,EAAE;AAAd,GADP,EAEJC,IAFI,CAECC,gBAAgB,IAAIA,gBAAgB,CAACC,aAAjB,CAA+B,IAA/B,CAFrB,EAGJF,IAHI,CAGCG,OAAO,KAAK;AAAEC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,OAAO,EAAEF;AAAX;AAAZ,GAAL,CAHR,CAAP;AAID;;AAED,SAASG,YAAT,CAAsBX,GAAtB,EAA2B;AACzB,QAAMY,SAAS,GAAGZ,GAAG,CAACa,MAAJ,CAAWD,SAA7B;AACA,SAAOZ,GAAG,CAACC,MAAJ,CAAWC,QAAX,CACJC,UADI,CACO;AAAEC,IAAAA,UAAU,EAAE;AAAd,GADP,EAEJC,IAFI,CAECC,gBAAgB,IAAIA,gBAAgB,CAACK,YAAjB,CAA8BC,SAA9B,EAAyC,IAAzC,CAFrB,EAGJP,IAHI,CAGCS,MAAM,KAAK;AAAEL,IAAAA,QAAQ,EAAEK;AAAZ,GAAL,CAHP,EAIJC,KAJI,CAIEC,KAAK,IAAI;AACd,QAAIA,KAAK,KAAKC,SAAd,EAAyB;AACvB,YAAM,IAAI1B,KAAK,CAACM,KAAV,CAAgBN,KAAK,CAACM,KAAN,CAAYC,kBAA5B,EAAiD,SAAQc,SAAU,kBAAnE,CAAN;AACD,KAFD,MAEO;AACL,YAAM,IAAIrB,KAAK,CAACM,KAAV,CAAgBN,KAAK,CAACM,KAAN,CAAYqB,qBAA5B,EAAmD,yBAAnD,CAAN;AACD;AACF,GAVI,CAAP;AAWD;;AAED,MAAMC,2BAA2B,GAAGnB,GAAG,IAAI;AAAA;;AACzC,MAAI,gBAAAA,GAAG,CAACC,MAAJ,kFAAYa,MAAZ,0EAAoBM,WAApB,MAAoC,IAAxC,EAA8C;AAC5C,UAAM,IAAI7B,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYwB,mBADR,EAEJ,6DAFI,CAAN;AAID;AACF,CAPD;;AASO,MAAMC,oBAAoB,GAAG,OAAOV,SAAP,EAAkBW,IAAlB,EAAwBtB,MAAxB,KAAmC;AACrE,QAAMuB,UAAU,GAAG,MAAMvB,MAAM,CAACC,QAAP,CAAgBC,UAAhB,CAA2B;AAAEC,IAAAA,UAAU,EAAE;AAAd,GAA3B,CAAzB;AACA,QAAMK,QAAQ,GAAG,MAAMe,UAAU,CAACC,mBAAX,CACrBb,SADqB,EAErBW,IAAI,CAACG,MAFgB,EAGrBH,IAAI,CAACI,qBAHgB,EAIrBJ,IAAI,CAACK,OAJgB,CAAvB;AAMA,SAAO;AACLnB,IAAAA;AADK,GAAP;AAGD,CAXM;;;;AAaA,MAAMoB,oBAAoB,GAAG,OAAOjB,SAAP,EAAkBW,IAAlB,EAAwBtB,MAAxB,KAAmC;AACrE,QAAMuB,UAAU,GAAG,MAAMvB,MAAM,CAACC,QAAP,CAAgBC,UAAhB,CAA2B;AAAEC,IAAAA,UAAU,EAAE;AAAd,GAA3B,CAAzB;AACA,QAAMK,QAAQ,GAAG,MAAMe,UAAU,CAACM,WAAX,CACrBlB,SADqB,EAErBW,IAAI,CAACG,MAAL,IAAe,EAFM,EAGrBH,IAAI,CAACI,qBAHgB,EAIrBJ,IAAI,CAACK,OAJgB,EAKrB3B,MAAM,CAACC,QALc,CAAvB;AAOA,SAAO;AAAEO,IAAAA;AAAF,GAAP;AACD,CAVM;;;;AAYP,eAAesB,YAAf,CAA4B/B,GAA5B,EAAiC;AAC/BmB,EAAAA,2BAA2B,CAACnB,GAAD,CAA3B;;AACA,MAAIA,GAAG,CAACgC,IAAJ,CAASC,UAAb,EAAyB;AACvB,UAAM,IAAI1C,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYwB,mBADR,EAEJ,uDAFI,CAAN;AAID;;AACD,MAAIrB,GAAG,CAACa,MAAJ,CAAWD,SAAX,IAAwBZ,GAAG,CAACuB,IAAJ,CAASX,SAArC,EAAgD;AAC9C,QAAIZ,GAAG,CAACa,MAAJ,CAAWD,SAAX,IAAwBZ,GAAG,CAACuB,IAAJ,CAASX,SAArC,EAAgD;AAC9C,aAAOlB,yBAAyB,CAACM,GAAG,CAACuB,IAAJ,CAASX,SAAV,EAAqBZ,GAAG,CAACa,MAAJ,CAAWD,SAAhC,CAAhC;AACD;AACF;;AAED,QAAMA,SAAS,GAAGZ,GAAG,CAACa,MAAJ,CAAWD,SAAX,IAAwBZ,GAAG,CAACuB,IAAJ,CAASX,SAAnD;;AACA,MAAI,CAACA,SAAL,EAAgB;AACd,UAAM,IAAIrB,KAAK,CAACM,KAAV,CAAgB,GAAhB,EAAsB,QAAOG,GAAG,CAACkC,IAAK,sBAAtC,CAAN;AACD;;AAED,SAAO,MAAMZ,oBAAoB,CAACV,SAAD,EAAYZ,GAAG,CAACuB,IAAhB,EAAsBvB,GAAG,CAACC,MAA1B,CAAjC;AACD;;AAED,SAASkC,YAAT,CAAsBnC,GAAtB,EAA2B;AACzBmB,EAAAA,2BAA2B,CAACnB,GAAD,CAA3B;;AACA,MAAIA,GAAG,CAACgC,IAAJ,CAASC,UAAb,EAAyB;AACvB,UAAM,IAAI1C,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYwB,mBADR,EAEJ,uDAFI,CAAN;AAID;;AACD,MAAIrB,GAAG,CAACuB,IAAJ,CAASX,SAAT,IAAsBZ,GAAG,CAACuB,IAAJ,CAASX,SAAT,IAAsBZ,GAAG,CAACa,MAAJ,CAAWD,SAA3D,EAAsE;AACpE,WAAOlB,yBAAyB,CAACM,GAAG,CAACuB,IAAJ,CAASX,SAAV,EAAqBZ,GAAG,CAACa,MAAJ,CAAWD,SAAhC,CAAhC;AACD;;AACD,QAAMA,SAAS,GAAGZ,GAAG,CAACa,MAAJ,CAAWD,SAA7B;AAEA,SAAOiB,oBAAoB,CAACjB,SAAD,EAAYZ,GAAG,CAACuB,IAAhB,EAAsBvB,GAAG,CAACC,MAA1B,CAA3B;AACD;;AAED,MAAMmC,YAAY,GAAGpC,GAAG,IAAI;AAC1B,MAAIA,GAAG,CAACgC,IAAJ,CAASC,UAAb,EAAyB;AACvB,UAAM,IAAI1C,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYwB,mBADR,EAEJ,uDAFI,CAAN;AAID;;AACD,MAAI,CAAC5B,gBAAgB,CAAC4C,gBAAjB,CAAkCrC,GAAG,CAACa,MAAJ,CAAWD,SAA7C,CAAL,EAA8D;AAC5D,UAAM,IAAIrB,KAAK,CAACM,KAAV,CACJN,KAAK,CAACM,KAAN,CAAYC,kBADR,EAEJL,gBAAgB,CAAC6C,uBAAjB,CAAyCtC,GAAG,CAACa,MAAJ,CAAWD,SAApD,CAFI,CAAN;AAID;;AACD,SAAOZ,GAAG,CAACC,MAAJ,CAAWC,QAAX,CAAoBkC,YAApB,CAAiCpC,GAAG,CAACa,MAAJ,CAAWD,SAA5C,EAAuDP,IAAvD,CAA4D,OAAO;AAAEI,IAAAA,QAAQ,EAAE;AAAZ,GAAP,CAA5D,CAAP;AACD,CAdD;;AAgBO,MAAM8B,aAAN,SAA4BC,sBAA5B,CAA0C;AAC/CC,EAAAA,WAAW,GAAG;AACZ,SAAKC,KAAL,CAAW,KAAX,EAAkB,UAAlB,EAA8BC,UAAU,CAACC,6BAAzC,EAAwE7C,aAAxE;AACA,SAAK2C,KAAL,CACE,KADF,EAEE,qBAFF,EAGEC,UAAU,CAACC,6BAHb,EAIEjC,YAJF;AAMA,SAAK+B,KAAL,CAAW,MAAX,EAAmB,UAAnB,EAA+BC,UAAU,CAACC,6BAA1C,EAAyEb,YAAzE;AACA,SAAKW,KAAL,CACE,MADF,EAEE,qBAFF,EAGEC,UAAU,CAACC,6BAHb,EAIEb,YAJF;AAMA,SAAKW,KAAL,CACE,KADF,EAEE,qBAFF,EAGEC,UAAU,CAACC,6BAHb,EAIET,YAJF;AAMA,SAAKO,KAAL,CACE,QADF,EAEE,qBAFF,EAGEC,UAAU,CAACC,6BAHb,EAIER,YAJF;AAMD;;AA5B8C","sourcesContent":["// schemas.js\n\nvar Parse = require('parse/node').Parse,\n  SchemaController = require('../Controllers/SchemaController');\n\nimport PromiseRouter from '../PromiseRouter';\nimport * as middleware from '../middlewares';\n\nfunction classNameMismatchResponse(bodyClass, pathClass) {\n  throw new Parse.Error(\n    Parse.Error.INVALID_CLASS_NAME,\n    `Class name mismatch between ${bodyClass} and ${pathClass}.`\n  );\n}\n\nfunction getAllSchemas(req) {\n  return req.config.database\n    .loadSchema({ clearCache: true })\n    .then(schemaController => schemaController.getAllClasses(true))\n    .then(schemas => ({ response: { results: schemas } }));\n}\n\nfunction getOneSchema(req) {\n  const className = req.params.className;\n  return req.config.database\n    .loadSchema({ clearCache: true })\n    .then(schemaController => schemaController.getOneSchema(className, true))\n    .then(schema => ({ response: schema }))\n    .catch(error => {\n      if (error === undefined) {\n        throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} does not exist.`);\n      } else {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error.');\n      }\n    });\n}\n\nconst checkIfDefinedSchemasIsUsed = req => {\n  if (req.config?.schema?.lockSchemas === true) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      'Cannot perform this operation when schemas options is used.'\n    );\n  }\n};\n\nexport const internalCreateSchema = async (className, body, config) => {\n  const controller = await config.database.loadSchema({ clearCache: true });\n  const response = await controller.addClassIfNotExists(\n    className,\n    body.fields,\n    body.classLevelPermissions,\n    body.indexes\n  );\n  return {\n    response,\n  };\n};\n\nexport const internalUpdateSchema = async (className, body, config) => {\n  const controller = await config.database.loadSchema({ clearCache: true });\n  const response = await controller.updateClass(\n    className,\n    body.fields || {},\n    body.classLevelPermissions,\n    body.indexes,\n    config.database\n  );\n  return { response };\n};\n\nasync function createSchema(req) {\n  checkIfDefinedSchemasIsUsed(req);\n  if (req.auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      \"read-only masterKey isn't allowed to create a schema.\"\n    );\n  }\n  if (req.params.className && req.body.className) {\n    if (req.params.className != req.body.className) {\n      return classNameMismatchResponse(req.body.className, req.params.className);\n    }\n  }\n\n  const className = req.params.className || req.body.className;\n  if (!className) {\n    throw new Parse.Error(135, `POST ${req.path} needs a class name.`);\n  }\n\n  return await internalCreateSchema(className, req.body, req.config);\n}\n\nfunction modifySchema(req) {\n  checkIfDefinedSchemasIsUsed(req);\n  if (req.auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      \"read-only masterKey isn't allowed to update a schema.\"\n    );\n  }\n  if (req.body.className && req.body.className != req.params.className) {\n    return classNameMismatchResponse(req.body.className, req.params.className);\n  }\n  const className = req.params.className;\n\n  return internalUpdateSchema(className, req.body, req.config);\n}\n\nconst deleteSchema = req => {\n  if (req.auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      \"read-only masterKey isn't allowed to delete a schema.\"\n    );\n  }\n  if (!SchemaController.classNameIsValid(req.params.className)) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_CLASS_NAME,\n      SchemaController.invalidClassNameMessage(req.params.className)\n    );\n  }\n  return req.config.database.deleteSchema(req.params.className).then(() => ({ response: {} }));\n};\n\nexport class SchemasRouter extends PromiseRouter {\n  mountRoutes() {\n    this.route('GET', '/schemas', middleware.promiseEnforceMasterKeyAccess, getAllSchemas);\n    this.route(\n      'GET',\n      '/schemas/:className',\n      middleware.promiseEnforceMasterKeyAccess,\n      getOneSchema\n    );\n    this.route('POST', '/schemas', middleware.promiseEnforceMasterKeyAccess, createSchema);\n    this.route(\n      'POST',\n      '/schemas/:className',\n      middleware.promiseEnforceMasterKeyAccess,\n      createSchema\n    );\n    this.route(\n      'PUT',\n      '/schemas/:className',\n      middleware.promiseEnforceMasterKeyAccess,\n      modifySchema\n    );\n    this.route(\n      'DELETE',\n      '/schemas/:className',\n      middleware.promiseEnforceMasterKeyAccess,\n      deleteSchema\n    );\n  }\n}\n"]}