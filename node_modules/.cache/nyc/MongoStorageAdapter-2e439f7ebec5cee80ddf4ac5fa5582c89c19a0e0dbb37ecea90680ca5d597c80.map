{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoStorageAdapter.js"],"names":["mongodb","require","MongoClient","ReadPreference","MongoSchemaCollectionName","storageAdapterAllCollections","mongoAdapter","connect","then","database","collections","filter","collection","namespace","match","collectionName","indexOf","_collectionPrefix","convertParseSchemaToMongoSchema","schema","fields","_rperm","_wperm","className","_hashed_password","mongoSchemaFromFieldsAndClassNameAndCLP","classLevelPermissions","indexes","mongoObject","_id","objectId","updatedAt","createdAt","_metadata","undefined","fieldName","type","targetClass","fieldOptions","MongoSchemaCollection","parseFieldTypeToMongoFieldType","Object","keys","length","fields_options","class_permissions","validateExplainValue","explain","explainAllowedValues","includes","Parse","Error","INVALID_QUERY","MongoStorageAdapter","constructor","uri","defaults","DefaultMongoURI","collectionPrefix","mongoOptions","_uri","_mongoOptions","useNewUrlParser","useUnifiedTopology","_onchange","_maxTimeMS","maxTimeMS","canSortOnJoinTables","enableSchemaHooks","watch","callback","connectionPromise","encodedUri","client","options","s","db","dbName","on","catch","err","Promise","reject","handleError","error","code","logger","handleShutdown","resolve","close","_adaptiveCollection","name","rawCollection","MongoCollection","_schemaCollection","_stream","_mongoCollection","classExists","listCollections","toArray","setClassLevelPermissions","CLPs","schemaCollection","updateSchema","$set","setIndexesWithSchemaFormat","submittedIndexes","existingIndexes","_id_","deletePromises","insertedIndexes","forEach","field","__op","promise","dropIndex","push","key","prototype","hasOwnProperty","call","replace","insertPromise","createIndexes","all","setIndexesFromMongo","getIndexes","reduce","obj","index","_fts","_ftsx","weights","createClass","insertSchema","updateFieldOptions","addFieldIfNotExists","createIndexesIfNeeded","deleteClass","drop","message","findAndDeleteSchema","deleteAllClasses","fast","map","deleteMany","deleteFields","fieldNames","mongoFormatNames","collectionUpdate","$unset","collectionFilter","$or","$exists","schemaUpdate","updateMany","getAllClasses","schemasCollection","_fetchAllSchemasFrom_SCHEMA","getClass","_fetchOneSchemaFrom_SCHEMA","createObject","object","transactionalSession","insertOne","DUPLICATE_VALUE","underlyingError","matches","Array","isArray","userInfo","duplicated_field","deleteObjectsByQuery","query","mongoWhere","result","n","OBJECT_NOT_FOUND","INTERNAL_SERVER_ERROR","updateObjectsByQuery","update","mongoUpdate","findOneAndUpdate","returnDocument","session","value","upsertOneObject","upsertOne","find","skip","limit","sort","readPreference","hint","caseInsensitive","mongoSort","_","mapKeys","mongoKeys","memo","_parseReadPreference","createTextIndexesIfNeeded","objects","ensureIndex","indexName","indexCreationRequest","mongoFieldNames","indexType","defaultOptions","background","sparse","indexNameOptions","ttlOptions","ttl","expireAfterSeconds","caseInsensitiveOptions","collation","caseInsensitiveCollation","indexOptions","createIndex","ensureUniqueness","_ensureSparseUniqueIndexInBackground","_rawFind","count","distinct","isPointerField","transformField","aggregate","pipeline","stage","$group","_parseAggregateGroupArgs","$match","_parseAggregateArgs","$project","_parseAggregateProjectArgs","$geoNear","results","split","isEmpty","returnValue","_convertToDate","substring","Date","toUpperCase","PRIMARY","PRIMARY_PREFERRED","SECONDARY","SECONDARY_PREFERRED","NEAREST","performInitialization","$text","textIndex","dropAllIndexes","dropIndexes","updateSchemaWithIndexes","classes","promises","createTransactionalSession","transactionalSection","startSession","startTransaction","commitTransactionalSession","commit","retries","commitTransaction","hasErrorLabel","endSession","abortTransactionalSession","abortTransaction"],"mappings":"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","sourcesContent":["// @flow\nimport MongoCollection from './MongoCollection';\nimport MongoSchemaCollection from './MongoSchemaCollection';\nimport { StorageAdapter } from '../StorageAdapter';\nimport type { SchemaType, QueryType, StorageClass, QueryOptions } from '../StorageAdapter';\nimport { parse as parseUrl, format as formatUrl } from '../../../vendor/mongodbUrl';\nimport {\n  parseObjectToMongoObjectForCreate,\n  mongoObjectToParseObject,\n  transformKey,\n  transformWhere,\n  transformUpdate,\n  transformPointerString,\n} from './MongoTransform';\n// @flow-disable-next\nimport Parse from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\nimport defaults from '../../../defaults';\nimport logger from '../../../logger';\n\n// @flow-disable-next\nconst mongodb = require('mongodb');\nconst MongoClient = mongodb.MongoClient;\nconst ReadPreference = mongodb.ReadPreference;\n\nconst MongoSchemaCollectionName = '_SCHEMA';\n\nconst storageAdapterAllCollections = mongoAdapter => {\n  return mongoAdapter\n    .connect()\n    .then(() => mongoAdapter.database.collections())\n    .then(collections => {\n      return collections.filter(collection => {\n        if (collection.namespace.match(/\\.system\\./)) {\n          return false;\n        }\n        // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n        // apps prefix, this will go very very badly. We should fix that somehow.\n        return collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0;\n      });\n    });\n};\n\nconst convertParseSchemaToMongoSchema = ({ ...schema }) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n};\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nconst mongoSchemaFromFieldsAndClassNameAndCLP = (\n  fields,\n  className,\n  classLevelPermissions,\n  indexes\n) => {\n  const mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string',\n    _metadata: undefined,\n  };\n\n  for (const fieldName in fields) {\n    const { type, targetClass, ...fieldOptions } = fields[fieldName];\n    mongoObject[fieldName] = MongoSchemaCollection.parseFieldTypeToMongoFieldType({\n      type,\n      targetClass,\n    });\n    if (fieldOptions && Object.keys(fieldOptions).length > 0) {\n      mongoObject._metadata = mongoObject._metadata || {};\n      mongoObject._metadata.fields_options = mongoObject._metadata.fields_options || {};\n      mongoObject._metadata.fields_options[fieldName] = fieldOptions;\n    }\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  if (indexes && typeof indexes === 'object' && Object.keys(indexes).length > 0) {\n    mongoObject._metadata = mongoObject._metadata || {};\n    mongoObject._metadata.indexes = indexes;\n  }\n\n  if (!mongoObject._metadata) {\n    // cleanup the unused _metadata\n    delete mongoObject._metadata;\n  }\n\n  return mongoObject;\n};\n\nfunction validateExplainValue(explain) {\n  if (explain) {\n    // The list of allowed explain values is from node-mongodb-native/lib/explain.js\n    const explainAllowedValues = [\n      'queryPlanner',\n      'queryPlannerExtended',\n      'executionStats',\n      'allPlansExecution',\n      false,\n      true,\n    ];\n    if (!explainAllowedValues.includes(explain)) {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Invalid value for explain');\n    }\n  }\n}\n\nexport class MongoStorageAdapter implements StorageAdapter {\n  // Private\n  _uri: string;\n  _collectionPrefix: string;\n  _mongoOptions: Object;\n  _onchange: any;\n  _stream: any;\n  // Public\n  connectionPromise: ?Promise<any>;\n  database: any;\n  client: MongoClient;\n  _maxTimeMS: ?number;\n  canSortOnJoinTables: boolean;\n  enableSchemaHooks: boolean;\n\n  constructor({ uri = defaults.DefaultMongoURI, collectionPrefix = '', mongoOptions = {} }: any) {\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n    this._mongoOptions.useNewUrlParser = true;\n    this._mongoOptions.useUnifiedTopology = true;\n    this._onchange = () => {};\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    this.canSortOnJoinTables = true;\n    this.enableSchemaHooks = !!mongoOptions.enableSchemaHooks;\n    delete mongoOptions.enableSchemaHooks;\n    delete mongoOptions.maxTimeMS;\n  }\n\n  watch(callback: () => void): void {\n    this._onchange = callback;\n  }\n\n  connect() {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // parsing and re-formatting causes the auth value (if there) to get URI\n    // encoded\n    const encodedUri = formatUrl(parseUrl(this._uri));\n\n    this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions)\n      .then(client => {\n        // Starting mongoDB 3.0, the MongoClient.connect don't return a DB anymore but a client\n        // Fortunately, we can get back the options and use them to select the proper DB.\n        // https://github.com/mongodb/node-mongodb-native/blob/2c35d76f08574225b8db02d7bef687123e6bb018/lib/mongo_client.js#L885\n        const options = client.s.options;\n        const database = client.db(options.dbName);\n        if (!database) {\n          delete this.connectionPromise;\n          return;\n        }\n        client.on('error', () => {\n          delete this.connectionPromise;\n        });\n        client.on('close', () => {\n          delete this.connectionPromise;\n        });\n        this.client = client;\n        this.database = database;\n      })\n      .catch(err => {\n        delete this.connectionPromise;\n        return Promise.reject(err);\n      });\n\n    return this.connectionPromise;\n  }\n\n  handleError<T>(error: ?(Error | Parse.Error)): Promise<T> {\n    if (error && error.code === 13) {\n      // Unauthorized error\n      delete this.client;\n      delete this.database;\n      delete this.connectionPromise;\n      logger.error('Received unauthorized error', { error: error });\n    }\n    throw error;\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return Promise.resolve();\n    }\n    return this.client.close(false);\n  }\n\n  _adaptiveCollection(name: string) {\n    return this.connect()\n      .then(() => this.database.collection(this._collectionPrefix + name))\n      .then(rawCollection => new MongoCollection(rawCollection))\n      .catch(err => this.handleError(err));\n  }\n\n  _schemaCollection(): Promise<MongoSchemaCollection> {\n    return this.connect()\n      .then(() => this._adaptiveCollection(MongoSchemaCollectionName))\n      .then(collection => {\n        if (!this._stream && this.enableSchemaHooks) {\n          this._stream = collection._mongoCollection.watch();\n          this._stream.on('change', () => this._onchange());\n        }\n        return new MongoSchemaCollection(collection);\n      });\n  }\n\n  classExists(name: string) {\n    return this.connect()\n      .then(() => {\n        return this.database.listCollections({ name: this._collectionPrefix + name }).toArray();\n      })\n      .then(collections => {\n        return collections.length > 0;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.class_permissions': CLPs },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesWithSchemaFormat(\n    className: string,\n    submittedIndexes: any,\n    existingIndexes: any = {},\n    fields: any\n  ): Promise<void> {\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1 } };\n    }\n    const deletePromises = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_QUERY,\n          `Index ${name} does not exist, cannot delete.`\n        );\n      }\n      if (field.__op === 'Delete') {\n        const promise = this.dropIndex(className, name);\n        deletePromises.push(promise);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (\n            !Object.prototype.hasOwnProperty.call(\n              fields,\n              key.indexOf('_p_') === 0 ? key.replace('_p_', '') : key\n            )\n          ) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_QUERY,\n              `Field ${key} does not exist, cannot add index.`\n            );\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    let insertPromise = Promise.resolve();\n    if (insertedIndexes.length > 0) {\n      insertPromise = this.createIndexes(className, insertedIndexes);\n    }\n    return Promise.all(deletePromises)\n      .then(() => insertPromise)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.indexes': existingIndexes },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesFromMongo(className: string) {\n    return this.getIndexes(className)\n      .then(indexes => {\n        indexes = indexes.reduce((obj, index) => {\n          if (index.key._fts) {\n            delete index.key._fts;\n            delete index.key._ftsx;\n            for (const field in index.weights) {\n              index.key[field] = 'text';\n            }\n          }\n          obj[index.name] = index.key;\n          return obj;\n        }, {});\n        return this._schemaCollection().then(schemaCollection =>\n          schemaCollection.updateSchema(className, {\n            $set: { '_metadata.indexes': indexes },\n          })\n        );\n      })\n      .catch(err => this.handleError(err))\n      .catch(() => {\n        // Ignore if collection not found\n        return Promise.resolve();\n      });\n  }\n\n  createClass(className: string, schema: SchemaType): Promise<void> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(\n      schema.fields,\n      className,\n      schema.classLevelPermissions,\n      schema.indexes\n    );\n    mongoObject._id = className;\n    return this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.insertSchema(mongoObject))\n      .catch(err => this.handleError(err));\n  }\n\n  async updateFieldOptions(className: string, fieldName: string, type: any) {\n    const schemaCollection = await this._schemaCollection();\n    await schemaCollection.updateFieldOptions(className, fieldName, type);\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.addFieldIfNotExists(className, fieldName, type))\n      .then(() => this.createIndexesIfNeeded(className, fieldName, type))\n      .catch(err => this.handleError(err));\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    return (\n      this._adaptiveCollection(className)\n        .then(collection => collection.drop())\n        .catch(error => {\n          // 'ns not found' means collection was already gone. Ignore deletion attempt.\n          if (error.message == 'ns not found') {\n            return;\n          }\n          throw error;\n        })\n        // We've dropped the collection, now remove the _SCHEMA document\n        .then(() => this._schemaCollection())\n        .then(schemaCollection => schemaCollection.findAndDeleteSchema(className))\n        .catch(err => this.handleError(err))\n    );\n  }\n\n  deleteAllClasses(fast: boolean) {\n    return storageAdapterAllCollections(this).then(collections =>\n      Promise.all(\n        collections.map(collection => (fast ? collection.deleteMany({}) : collection.drop()))\n      )\n    );\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // Pointer field names are passed for legacy reasons: the original mongo\n  // format stored pointer field names differently in the database, and therefore\n  // needed to know the type of the field before it could delete it. Future database\n  // adapters should ignore the pointerFieldNames argument. All the field names are in\n  // fieldNames, they show up additionally in the pointerFieldNames database for use\n  // by the mongo adapter, which deals with the legacy mongo format.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]) {\n    const mongoFormatNames = fieldNames.map(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer') {\n        return `_p_${fieldName}`;\n      } else {\n        return fieldName;\n      }\n    });\n    const collectionUpdate = { $unset: {} };\n    mongoFormatNames.forEach(name => {\n      collectionUpdate['$unset'][name] = null;\n    });\n\n    const collectionFilter = { $or: [] };\n    mongoFormatNames.forEach(name => {\n      collectionFilter['$or'].push({ [name]: { $exists: true } });\n    });\n\n    const schemaUpdate = { $unset: {} };\n    fieldNames.forEach(name => {\n      schemaUpdate['$unset'][name] = null;\n      schemaUpdate['$unset'][`_metadata.fields_options.${name}`] = null;\n    });\n\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(collectionFilter, collectionUpdate))\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, schemaUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses(): Promise<StorageClass[]> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchAllSchemasFrom_SCHEMA())\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string): Promise<StorageClass> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchOneSchemaFrom_SCHEMA(className))\n      .catch(err => this.handleError(err));\n  }\n\n  // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n  // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n  // the schema only for the legacy mongo format. We'll figure that out later.\n  createObject(className: string, schema: SchemaType, object: any, transactionalSession: ?any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = parseObjectToMongoObjectForCreate(className, object, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.insertOne(mongoObject, transactionalSession))\n      .catch(error => {\n        if (error.code === 11000) {\n          // Duplicate value\n          const err = new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n          err.underlyingError = error;\n          if (error.message) {\n            const matches = error.message.match(/index:[\\sa-zA-Z0-9_\\-\\.]+\\$?([a-zA-Z_-]+)_1/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          throw err;\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    return this._adaptiveCollection(className)\n      .then(collection => {\n        const mongoWhere = transformWhere(className, query, schema);\n        return collection.deleteMany(mongoWhere, transactionalSession);\n      })\n      .catch(err => this.handleError(err))\n      .then(\n        ({ result }) => {\n          if (result.n === 0) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          return Promise.resolve();\n        },\n        () => {\n          throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n        }\n      );\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Atomically finds and updates an object based on query.\n  // Return value not currently well specified.\n  findOneAndUpdate(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection._mongoCollection.findOneAndUpdate(mongoWhere, mongoUpdate, {\n          returnDocument: 'after',\n          session: transactionalSession || undefined,\n        })\n      )\n      .then(result => mongoObjectToParseObject(className, result.value, schema))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Hopefully we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.upsertOne(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n  find(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    { skip, limit, sort, keys, readPreference, hint, caseInsensitive, explain }: QueryOptions\n  ): Promise<any> {\n    validateExplainValue(explain);\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    const mongoSort = _.mapKeys(sort, (value, fieldName) =>\n      transformKey(className, fieldName, schema)\n    );\n    const mongoKeys = _.reduce(\n      keys,\n      (memo, key) => {\n        if (key === 'ACL') {\n          memo['_rperm'] = 1;\n          memo['_wperm'] = 1;\n        } else {\n          memo[transformKey(className, key, schema)] = 1;\n        }\n        return memo;\n      },\n      {}\n    );\n\n    // If we aren't requesting the `_id` field, we need to explicitly opt out\n    // of it. Doing so in parse-server is unusual, but it can allow us to\n    // optimize some queries with covering indexes.\n    if (keys && !mongoKeys._id) {\n      mongoKeys._id = 0;\n    }\n\n    readPreference = this._parseReadPreference(readPreference);\n    return this.createTextIndexesIfNeeded(className, query, schema)\n      .then(() => this._adaptiveCollection(className))\n      .then(collection =>\n        collection.find(mongoWhere, {\n          skip,\n          limit,\n          sort: mongoSort,\n          keys: mongoKeys,\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n          caseInsensitive,\n          explain,\n        })\n      )\n      .then(objects => {\n        if (explain) {\n          return objects;\n        }\n        return objects.map(object => mongoObjectToParseObject(className, object, schema));\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  ensureIndex(\n    className: string,\n    schema: SchemaType,\n    fieldNames: string[],\n    indexName: ?string,\n    caseInsensitive: boolean = false,\n    options?: Object = {}\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = options.indexType !== undefined ? options.indexType : 1;\n    });\n\n    const defaultOptions: Object = { background: true, sparse: true };\n    const indexNameOptions: Object = indexName ? { name: indexName } : {};\n    const ttlOptions: Object = options.ttl !== undefined ? { expireAfterSeconds: options.ttl } : {};\n    const caseInsensitiveOptions: Object = caseInsensitive\n      ? { collation: MongoCollection.caseInsensitiveCollation() }\n      : {};\n    const indexOptions: Object = {\n      ...defaultOptions,\n      ...caseInsensitiveOptions,\n      ...indexNameOptions,\n      ...ttlOptions,\n    };\n\n    return this._adaptiveCollection(className)\n      .then(\n        collection =>\n          new Promise((resolve, reject) =>\n            collection._mongoCollection.createIndex(indexCreationRequest, indexOptions, error =>\n              error ? reject(error) : resolve()\n            )\n          )\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = 1;\n    });\n    return this._adaptiveCollection(className)\n      .then(collection => collection._ensureSparseUniqueIndexInBackground(indexCreationRequest))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'Tried to ensure field uniqueness for a class that already has duplicates.'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Used in tests\n  _rawFind(className: string, query: QueryType) {\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.find(query, {\n          maxTimeMS: this._maxTimeMS,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a count.\n  count(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    readPreference: ?string,\n    hint: ?mixed\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.count(transformWhere(className, query, schema, true), {\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const isPointerField = schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    const transformField = transformKey(className, fieldName, schema);\n\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.distinct(transformField, transformWhere(className, query, schema))\n      )\n      .then(objects => {\n        objects = objects.filter(obj => obj != null);\n        return objects.map(object => {\n          if (isPointerField) {\n            return transformPointerString(schema, fieldName, object);\n          }\n          return mongoObjectToParseObject(className, object, schema);\n        });\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  aggregate(\n    className: string,\n    schema: any,\n    pipeline: any,\n    readPreference: ?string,\n    hint: ?mixed,\n    explain?: boolean\n  ) {\n    validateExplainValue(explain);\n    let isPointerField = false;\n    pipeline = pipeline.map(stage => {\n      if (stage.$group) {\n        stage.$group = this._parseAggregateGroupArgs(schema, stage.$group);\n        if (\n          stage.$group._id &&\n          typeof stage.$group._id === 'string' &&\n          stage.$group._id.indexOf('$_p_') >= 0\n        ) {\n          isPointerField = true;\n        }\n      }\n      if (stage.$match) {\n        stage.$match = this._parseAggregateArgs(schema, stage.$match);\n      }\n      if (stage.$project) {\n        stage.$project = this._parseAggregateProjectArgs(schema, stage.$project);\n      }\n      if (stage.$geoNear && stage.$geoNear.query) {\n        stage.$geoNear.query = this._parseAggregateArgs(schema, stage.$geoNear.query);\n      }\n      return stage;\n    });\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.aggregate(pipeline, {\n          readPreference,\n          maxTimeMS: this._maxTimeMS,\n          hint,\n          explain,\n        })\n      )\n      .then(results => {\n        results.forEach(result => {\n          if (Object.prototype.hasOwnProperty.call(result, '_id')) {\n            if (isPointerField && result._id) {\n              result._id = result._id.split('$')[1];\n            }\n            if (\n              result._id == null ||\n              result._id == undefined ||\n              (['object', 'string'].includes(typeof result._id) && _.isEmpty(result._id))\n            ) {\n              result._id = null;\n            }\n            result.objectId = result._id;\n            delete result._id;\n          }\n        });\n        return results;\n      })\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // This function will recursively traverse the pipeline and convert any Pointer or Date columns.\n  // If we detect a pointer column we will rename the column being queried for to match the column\n  // in the database. We also modify the value to what we expect the value to be in the database\n  // as well.\n  // For dates, the driver expects a Date object, but we have a string coming in. So we'll convert\n  // the string to a Date so the driver can perform the necessary comparison.\n  //\n  // The goal of this method is to look for the \"leaves\" of the pipeline and determine if it needs\n  // to be converted. The pipeline can have a few different forms. For more details, see:\n  //     https://docs.mongodb.com/manual/reference/operator/aggregation/\n  //\n  // If the pipeline is an array, it means we are probably parsing an '$and' or '$or' operator. In\n  // that case we need to loop through all of it's children to find the columns being operated on.\n  // If the pipeline is an object, then we'll loop through the keys checking to see if the key name\n  // matches one of the schema columns. If it does match a column and the column is a Pointer or\n  // a Date, then we'll convert the value as described above.\n  //\n  // As much as I hate recursion...this seemed like a good fit for it. We're essentially traversing\n  // down a tree to find a \"leaf node\" and checking to see if it needs to be converted.\n  _parseAggregateArgs(schema: any, pipeline: any): any {\n    if (pipeline === null) {\n      return null;\n    } else if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n          if (typeof pipeline[field] === 'object') {\n            // Pass objects down to MongoDB...this is more than likely an $exists operator.\n            returnValue[`_p_${field}`] = pipeline[field];\n          } else {\n            returnValue[`_p_${field}`] = `${schema.fields[field].targetClass}$${pipeline[field]}`;\n          }\n        } else if (schema.fields[field] && schema.fields[field].type === 'Date') {\n          returnValue[field] = this._convertToDate(pipeline[field]);\n        } else {\n          returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n        }\n\n        if (field === 'objectId') {\n          returnValue['_id'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'createdAt') {\n          returnValue['_created_at'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'updatedAt') {\n          returnValue['_updated_at'] = returnValue[field];\n          delete returnValue[field];\n        }\n      }\n      return returnValue;\n    }\n    return pipeline;\n  }\n\n  // This function is slightly different than the one above. Rather than trying to combine these\n  // two functions and making the code even harder to understand, I decided to split it up. The\n  // difference with this function is we are not transforming the values, only the keys of the\n  // pipeline.\n  _parseAggregateProjectArgs(schema: any, pipeline: any): any {\n    const returnValue = {};\n    for (const field in pipeline) {\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        returnValue[`_p_${field}`] = pipeline[field];\n      } else {\n        returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n      }\n\n      if (field === 'objectId') {\n        returnValue['_id'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'createdAt') {\n        returnValue['_created_at'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'updatedAt') {\n        returnValue['_updated_at'] = returnValue[field];\n        delete returnValue[field];\n      }\n    }\n    return returnValue;\n  }\n\n  // This function is slightly different than the two above. MongoDB $group aggregate looks like:\n  //     { $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }\n  // The <expression> could be a column name, prefixed with the '$' character. We'll look for\n  // these <expression> and check to see if it is a 'Pointer' or if it's one of createdAt,\n  // updatedAt or objectId and change it accordingly.\n  _parseAggregateGroupArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateGroupArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        returnValue[field] = this._parseAggregateGroupArgs(schema, pipeline[field]);\n      }\n      return returnValue;\n    } else if (typeof pipeline === 'string') {\n      const field = pipeline.substring(1);\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        return `$_p_${field}`;\n      } else if (field == 'createdAt') {\n        return '$_created_at';\n      } else if (field == 'updatedAt') {\n        return '$_updated_at';\n      }\n    }\n    return pipeline;\n  }\n\n  // This function will attempt to convert the provided value to a Date object. Since this is part\n  // of an aggregation pipeline, the value can either be a string or it can be another object with\n  // an operator in it (like $gt, $lt, etc). Because of this I felt it was easier to make this a\n  // recursive method to traverse down to the \"leaf node\" which is going to be the string.\n  _convertToDate(value: any): any {\n    if (typeof value === 'string') {\n      return new Date(value);\n    }\n\n    const returnValue = {};\n    for (const field in value) {\n      returnValue[field] = this._convertToDate(value[field]);\n    }\n    return returnValue;\n  }\n\n  _parseReadPreference(readPreference: ?string): ?string {\n    if (readPreference) {\n      readPreference = readPreference.toUpperCase();\n    }\n    switch (readPreference) {\n      case 'PRIMARY':\n        readPreference = ReadPreference.PRIMARY;\n        break;\n      case 'PRIMARY_PREFERRED':\n        readPreference = ReadPreference.PRIMARY_PREFERRED;\n        break;\n      case 'SECONDARY':\n        readPreference = ReadPreference.SECONDARY;\n        break;\n      case 'SECONDARY_PREFERRED':\n        readPreference = ReadPreference.SECONDARY_PREFERRED;\n        break;\n      case 'NEAREST':\n        readPreference = ReadPreference.NEAREST;\n        break;\n      case undefined:\n      case null:\n      case '':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Not supported read preference.');\n    }\n    return readPreference;\n  }\n\n  performInitialization(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  createIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexes(className: string, indexes: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndexes(indexes))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any) {\n    if (type && type.type === 'Polygon') {\n      const index = {\n        [fieldName]: '2dsphere',\n      };\n      return this.createIndex(className, index);\n    }\n    return Promise.resolve();\n  }\n\n  createTextIndexesIfNeeded(className: string, query: QueryType, schema: any): Promise<void> {\n    for (const fieldName in query) {\n      if (!query[fieldName] || !query[fieldName].$text) {\n        continue;\n      }\n      const existingIndexes = schema.indexes;\n      for (const key in existingIndexes) {\n        const index = existingIndexes[key];\n        if (Object.prototype.hasOwnProperty.call(index, fieldName)) {\n          return Promise.resolve();\n        }\n      }\n      const indexName = `${fieldName}_text`;\n      const textIndex = {\n        [indexName]: { [fieldName]: 'text' },\n      };\n      return this.setIndexesWithSchemaFormat(\n        className,\n        textIndex,\n        existingIndexes,\n        schema.fields\n      ).catch(error => {\n        if (error.code === 85) {\n          // Index exist with different options\n          return this.setIndexesFromMongo(className);\n        }\n        throw error;\n      });\n    }\n    return Promise.resolve();\n  }\n\n  getIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.indexes())\n      .catch(err => this.handleError(err));\n  }\n\n  dropIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  dropAllIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndexes())\n      .catch(err => this.handleError(err));\n  }\n\n  updateSchemaWithIndexes(): Promise<any> {\n    return this.getAllClasses()\n      .then(classes => {\n        const promises = classes.map(schema => {\n          return this.setIndexesFromMongo(schema.className);\n        });\n        return Promise.all(promises);\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  createTransactionalSession(): Promise<any> {\n    const transactionalSection = this.client.startSession();\n    transactionalSection.startTransaction();\n    return Promise.resolve(transactionalSection);\n  }\n\n  commitTransactionalSession(transactionalSection: any): Promise<void> {\n    const commit = retries => {\n      return transactionalSection\n        .commitTransaction()\n        .catch(error => {\n          if (error && error.hasErrorLabel('TransientTransactionError') && retries > 0) {\n            return commit(retries - 1);\n          }\n          throw error;\n        })\n        .then(() => {\n          transactionalSection.endSession();\n        });\n    };\n    return commit(5);\n  }\n\n  abortTransactionalSession(transactionalSection: any): Promise<void> {\n    return transactionalSection.abortTransaction().then(() => {\n      transactionalSection.endSession();\n    });\n  }\n}\n\nexport default MongoStorageAdapter;\n"]}