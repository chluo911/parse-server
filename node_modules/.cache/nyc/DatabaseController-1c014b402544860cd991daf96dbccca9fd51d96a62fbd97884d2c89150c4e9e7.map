{"version":3,"sources":["../../src/Controllers/DatabaseController.js"],"names":["addWriteACL","query","acl","newQuery","_","cloneDeep","_wperm","$in","addReadACL","_rperm","transformObjectACL","ACL","result","entry","read","push","write","specialQuerykeys","isSpecialQueryKey","key","indexOf","validateQuery","Parse","Error","INVALID_QUERY","$or","Array","forEach","$and","$nor","length","Object","keys","$regex","$options","match","INVALID_KEY_NAME","filterSensitiveData","isMaster","aclGroup","auth","operation","schema","className","protectedFields","object","userId","user","id","perms","getClassLevelPermissions","isReadOperation","protectedFieldsPointerPerm","filter","startsWith","map","substring","value","newProtectedFields","overrideProtectedFields","pointerPerm","pointerPermIncludesUser","readUserFieldValue","isArray","some","objectId","fields","v","includes","isUserClass","k","temporaryKeys","password","_hashed_password","sessionToken","_email_verify_token","_perishable_token","_perishable_token_expires_at","_tombstone","_email_verify_token_expires_at","_failed_login_count","_account_lockout_expires_at","_password_changed_at","_password_history","authData","specialKeysForUpdate","isSpecialUpdateKey","expandResultOnKeyPath","path","split","firstKey","nextPath","slice","join","sanitizeDatabaseResult","originalObject","response","Promise","resolve","keyUpdate","__op","joinTableName","flattenUpdateOperatorsForCreate","amount","INVALID_JSON","objects","COMMAND_UNAVAILABLE","transformAuthData","provider","providerData","fieldName","type","untransformObjectACL","output","getRootFieldName","relationSchema","relatedId","owningId","DatabaseController","constructor","adapter","schemaPromise","_transactionalSession","collectionExists","classExists","purgeCollection","loadSchema","then","schemaController","getOneSchema","deleteObjectsByQuery","validateClassName","SchemaController","classNameIsValid","reject","INVALID_CLASS_NAME","options","clearCache","load","loadSchemaIfNeeded","redirectClassNameForKey","t","getExpectedType","targetClass","validateObject","runOptions","undefined","s","canAddField","update","many","upsert","addsField","skipSanitization","validateOnly","validSchemaController","originalQuery","originalUpdate","relationUpdates","validatePermission","collectRelationUpdates","addPointerPermissions","catch","error","rootFieldName","fieldNameIsValid","updateOperation","innerKey","INVALID_NESTED_KEY","find","OBJECT_NOT_FOUND","updateObjectsByQuery","upsertOneObject","findOneAndUpdate","handleRelationUpdates","ops","deleteMe","process","op","x","pending","addRelation","removeRelation","all","fromClassName","fromId","toId","doc","code","destroy","parseFormatSchema","create","createdAt","iso","__type","updatedAt","enforceClassExists","createObject","convertSchemaToAdapterSchema","classSchema","schemaData","schemaFields","newKeys","field","action","deleteEverything","fast","SchemaCache","clear","deleteAllClasses","relatedIds","queryOptions","skip","limit","sort","findOptions","canSortOnJoinTables","_id","results","owningIds","reduceInRelation","ors","aQuery","index","ands","promises","queries","constraintKey","isNegation","r","q","ids","addNotInObjectIdsIds","addInObjectIdsIds","reduceRelationKeys","relatedTo","idsFromString","idsFromEq","idsFromIn","allIds","list","totalLength","reduce","memo","idsIntersection","intersect","big","$eq","idsFromNin","Set","$nin","count","distinct","pipeline","readPreference","hint","caseInsensitive","explain","_created_at","_updated_at","addProtectedFields","aggregate","INTERNAL_SERVER_ERROR","deleteSchema","deleteClass","wasParseCollection","relationFieldNames","name","del","reloadData","objectToEntriesStrings","entries","a","JSON","stringify","reduceOrOperation","repeat","i","j","shorter","longer","foundEntries","acc","shorterEntries","splice","reduceAndOperation","testPermissionsForClassName","userACL","groupKey","permFields","pointerFields","userPointer","fieldDescriptor","fieldType","prototype","hasOwnProperty","call","queryClause","$all","assign","preserveKeys","serverOnlyKeys","authenticated","roles","userRoles","protectedKeysSets","protectedKeys","next","createTransactionalSession","transactionalSession","commitTransactionalSession","abortTransactionalSession","performInitialization","VolatileClassesSchemas","requiredUserFields","defaultColumns","_Default","_User","requiredRoleFields","_Role","requiredIdempotencyFields","_Idempotency","MongoStorageAdapter","ensureUniqueness","logger","warn","ensureIndex","ttl","updateSchemaWithIndexes","module","exports","_validateQuery"],"mappings":"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","sourcesContent":["﻿// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\nimport SchemaCache from '../Adapters/Cache/SchemaCache';\nimport type { LoadSchemaOptions } from './types';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQuerykeys = [\n  '$and',\n  '$or',\n  '$nor',\n  '_rperm',\n  '_wperm',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms = schema.getClassLevelPermissions(className);\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction expandResultOnKeyPath(object, key, value) {\n  if (key.indexOf('.') < 0) {\n    object[key] = value[key];\n    return object;\n  }\n  const path = key.split('.');\n  const firstKey = path[0];\n  const nextPath = path.slice(1).join('.');\n  object[firstKey] = expandResultOnKeyPath(object[firstKey] || {}, nextPath, value[firstKey]);\n  delete object[key];\n  return object;\n}\n\nfunction sanitizeDatabaseResult(originalObject, result): Promise<any> {\n  const response = {};\n  if (!result) {\n    return Promise.resolve(response);\n  }\n  Object.keys(originalObject).forEach(key => {\n    const keyUpdate = originalObject[key];\n    // determine if that was an op\n    if (\n      keyUpdate &&\n      typeof keyUpdate === 'object' &&\n      keyUpdate.__op &&\n      ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n    ) {\n      // only valid ops that produce an actionable result\n      // the op may have happend on a keypath\n      expandResultOnKeyPath(response, key, result);\n    }\n  });\n  return Promise.resolve(response);\n}\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n\n  constructor(adapter: StorageAdapter) {\n    this.adapter = adapter;\n    // We don't want a mutable this.schema, because then you could have\n    // one request that uses different schemas for different parts of\n    // it. Instead, use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(getRootFieldName(field)) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    SchemaCache.clear();\n    return this.adapter.deleteAllClasses(fast);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n    if (query['$and']) {\n      const ands = query['$and'];\n      return Promise.all(\n        ands.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$and'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    if (query['$and']) {\n      return Promise.all(\n        query['$and'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    let schemaController;\n    return this.loadSchema({ clearCache: true })\n      .then(s => {\n        schemaController = s;\n        return schemaController.getOneSchema(className, true);\n      })\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                SchemaCache.del(className);\n                return schemaController.reloadData();\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms = schema.getClassLevelPermissions(className);\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  async performInitialization() {\n    await this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n    await this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    if (this.adapter instanceof MongoStorageAdapter) {\n      await this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'));\n    }\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for usernames: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['email'], 'case_insensitive_email', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for role name: ', error);\n      throw error;\n    });\n    if (this.adapter instanceof MongoStorageAdapter) {\n      await this.adapter\n        .ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n        .catch(error => {\n          logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n          throw error;\n        });\n\n      await this.adapter\n        .ensureIndex('_Idempotency', requiredIdempotencyFields, ['expire'], 'ttl', false, {\n          ttl: 0,\n        })\n        .catch(error => {\n          logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n          throw error;\n        });\n    }\n    await this.adapter.updateSchemaWithIndexes();\n  }\n\n  static _validateQuery: any => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\n"]}