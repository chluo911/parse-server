{"version":3,"sources":["../../src/LiveQuery/ParseLiveQueryServer.js"],"names":["ParseLiveQueryServer","constructor","server","config","parseServerConfig","clients","Map","subscriptions","appId","Parse","applicationId","masterKey","keyPairs","key","Object","keys","set","logger","verbose","disableSingleInstance","serverURL","initialize","javaScriptKey","cacheController","cacheTimeout","authCache","LRU","max","maxAge","parseWebSocketServer","ParseWebSocketServer","parseWebsocket","_onConnect","subscriber","ParsePubSub","createSubscriber","subscribe","on","channel","messageStr","message","JSON","parse","e","error","_inflateParseObject","_onAfterSave","_onAfterDelete","currentParseObject","UserRouter","removeHiddenProperties","className","parseObject","_finishFetch","originalParseObject","deletedParseObject","toJSON","classLevelPermissions","id","size","classSubscriptions","get","debug","subscription","values","isSubscriptionMatched","_matchesSubscription","clientId","requestIds","_","entries","clientRequestIds","client","forEach","requestId","acl","getACL","op","_getCLPOperation","query","res","_matchesCLP","isMatched","_matchesACL","event","sessionToken","object","useMasterKey","hasMasterKey","installationId","sendEvent","trigger","auth","getAuthFromClient","user","fromJSON","authData","pushDelete","Client","pushError","parseWebSocket","code","Error","SCRIPT_FAILED","stringify","isOriginalSubscriptionMatched","isCurrentSubscriptionMatched","originalACLCheckingPromise","Promise","resolve","originalACL","currentACLCheckingPromise","currentACL","isOriginalMatched","isCurrentMatched","all","hash","type","original","functionName","charAt","toUpperCase","slice","request","tv4","validate","RequestSchema","_handleConnect","_handleSubscribe","_handleUpdateSubscription","_handleUnsubscribe","info","has","delete","subscriptionInfo","subscriptionInfos","deleteClientSubscription","hasSubscribingClient","getAuthForSessionToken","fromCache","authPromise","then","userId","catch","result","INVALID_SESSION_TOKEN","del","getSubscriptionInfo","aclGroup","push","SchemaController","validatePermission","length","objectId","_verifyACL","token","isSubscriptionSessionTokenMatched","getReadAccess","acl_has_roles","permissionsById","some","startsWith","roleNames","getUserRoles","role","getSessionFromClient","getPublicReadAccess","subscriptionToken","clientSessionToken","_validateKeys","_hasMasterKey","req","pushConnect","validKeyPairs","prototype","hasOwnProperty","call","isValid","secret","authCalled","parseQuery","Query","withJSON","fields","split","where","toPointer","master","subscriptionHash","Subscription","addSubscriptionInfo","addClientSubscription","pushSubscribe","notifyClient","deleteSubscriptionInfo","pushUnsubscribe"],"mappings":"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","sourcesContent":["import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { runLiveQueryEventHandlers, getTrigger, runTrigger, toJSONwithObjects } from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n    this.config = config;\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(parseServerConfig);\n\n    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: config.cacheTimeout,\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe message %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          try {\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const isMatched = await this._matchesACL(acl, client, requestId);\n            if (!isMatched) {\n              return null;\n            }\n            res = {\n              event: 'delete',\n              sessionToken: client.sessionToken,\n              object: deletedParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              deletedParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            if (\n              (deletedParseObject.className === '_User' ||\n                deletedParseObject.className === '_Session') &&\n              !client.hasMasterKey\n            ) {\n              delete deletedParseObject.sessionToken;\n              delete deletedParseObject.authData;\n            }\n            client.pushDelete(requestId, deletedParseObject);\n          } catch (error) {\n            Client.pushError(\n              client.parseWebSocket,\n              error.code || Parse.Error.SCRIPT_FAILED,\n              error.message || error,\n              false,\n              requestId\n            );\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(originalACL, client, requestId);\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(currentACL, client, requestId);\n          }\n          try {\n            const op = this._getCLPOperation(subscription.query);\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const [isOriginalMatched, isCurrentMatched] = await Promise.all([\n              originalACLCheckingPromise,\n              currentACLCheckingPromise,\n            ]);\n            logger.verbose(\n              'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n              originalParseObject,\n              currentParseObject,\n              isOriginalSubscriptionMatched,\n              isCurrentSubscriptionMatched,\n              isOriginalMatched,\n              isCurrentMatched,\n              subscription.hash\n            );\n            // Decide event type\n            let type;\n            if (isOriginalMatched && isCurrentMatched) {\n              type = 'update';\n            } else if (isOriginalMatched && !isCurrentMatched) {\n              type = 'leave';\n            } else if (!isOriginalMatched && isCurrentMatched) {\n              if (originalParseObject) {\n                type = 'enter';\n              } else {\n                type = 'create';\n              }\n            } else {\n              return null;\n            }\n            res = {\n              event: type,\n              sessionToken: client.sessionToken,\n              object: currentParseObject,\n              original: originalParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              if (res.original) {\n                res.original = Parse.Object.fromJSON(res.original);\n              }\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              currentParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            if (res.original && typeof res.original.toJSON === 'function') {\n              originalParseObject = toJSONwithObjects(\n                res.original,\n                res.original.className || className\n              );\n            }\n            if (\n              (currentParseObject.className === '_User' ||\n                currentParseObject.className === '_Session') &&\n              !client.hasMasterKey\n            ) {\n              delete currentParseObject.sessionToken;\n              delete originalParseObject?.sessionToken;\n              delete currentParseObject.authData;\n              delete originalParseObject?.authData;\n            }\n            const functionName = 'push' + res.event.charAt(0).toUpperCase() + res.event.slice(1);\n            if (client[functionName]) {\n              client[functionName](requestId, currentParseObject, originalParseObject);\n            }\n          } catch (error) {\n            Client.pushError(\n              client.parseWebSocket,\n              error.code || Parse.Error.SCRIPT_FAILED,\n              error.message || error,\n              false,\n              requestId\n            );\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(client.subscriptionInfos)) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(subscription.className);\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n        sessionToken: client.sessionToken,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(sessionToken: ?string): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          result.error = error;\n          this.authCache.set(sessionToken, Promise.resolve(result), this.config.cacheTimeout);\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(subscriptionInfo.sessionToken);\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key => key.startsWith('role:'));\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async getAuthFromClient(client: any, requestId: number, sessionToken: string) {\n    const getSessionFromClient = () => {\n      const subscriptionInfo = client.getSubscriptionInfo(requestId);\n      if (typeof subscriptionInfo === 'undefined') {\n        return client.sessionToken;\n      }\n      return subscriptionInfo.sessionToken || client.sessionToken;\n    };\n    if (!sessionToken) {\n      sessionToken = getSessionFromClient();\n    }\n    if (!sessionToken) {\n      return;\n    }\n    const { auth } = await this.getAuthForSessionToken(sessionToken);\n    return auth;\n  }\n\n  async _matchesACL(acl: any, client: any, requestId: number): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      const trigger = getTrigger('@Connect', 'beforeConnect', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, req.sessionToken);\n        if (auth && auth.user) {\n          req.user = auth.user;\n        }\n        await runTrigger(trigger, `beforeConnect.@Connect`, req, auth);\n      }\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (error) {\n      Client.pushError(\n        parseWebsocket,\n        error.code || Parse.Error.SCRIPT_FAILED,\n        error.message || error,\n        false\n      );\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0 || !validKeyPairs.has('masterKey')) {\n      return false;\n    }\n    if (!request || !Object.prototype.hasOwnProperty.call(request, 'masterKey')) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error('Can not find this client, make sure you connect to server before subscribing');\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    let authCalled = false;\n    try {\n      const trigger = getTrigger(className, 'beforeSubscribe', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, request.sessionToken);\n        authCalled = true;\n        if (auth && auth.user) {\n          request.user = auth.user;\n        }\n\n        const parseQuery = new Parse.Query(className);\n        parseQuery.withJSON(request.query);\n        request.query = parseQuery;\n        await runTrigger(trigger, `beforeSubscribe.${className}`, request, auth);\n\n        const query = request.query.toJSON();\n        if (query.keys) {\n          query.fields = query.keys.split(',');\n        }\n        request.query = query;\n      }\n\n      if (className === '_Session') {\n        if (!authCalled) {\n          const auth = await this.getAuthFromClient(\n            client,\n            request.requestId,\n            request.sessionToken\n          );\n          if (auth && auth.user) {\n            request.user = auth.user;\n          }\n        }\n        if (request.user) {\n          request.query.where.user = request.user.toPointer();\n        } else if (!request.master) {\n          Client.pushError(\n            parseWebsocket,\n            Parse.Error.INVALID_SESSION_TOKEN,\n            'Invalid session token',\n            false,\n            request.requestId\n          );\n          return;\n        }\n      }\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(className, request.query.where, subscriptionHash);\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      Client.pushError(\n        parseWebsocket,\n        e.code || Parse.Error.SCRIPT_FAILED,\n        e.message || e,\n        false,\n        request.requestId\n      );\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(e)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(parseWebsocket: any, request: any, notifyClient: boolean = true): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n"]}