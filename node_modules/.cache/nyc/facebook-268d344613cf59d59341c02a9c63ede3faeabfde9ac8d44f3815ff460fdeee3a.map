{"version":3,"sources":["../../../src/Adapters/Auth/facebook.js"],"names":["Parse","require","crypto","jwksClient","util","jwt","httpsRequest","TOKEN_ISSUER","getAppSecretPath","authData","options","appSecret","appsecret_proof","createHmac","update","access_token","digest","validateGraphToken","graphRequest","then","data","id","process","env","TESTING","Error","OBJECT_NOT_FOUND","validateGraphAppId","appIds","Promise","resolve","length","indexOf","getFacebookKeyByKeyId","keyId","cacheMaxEntries","cacheMaxAge","client","jwksUri","cache","asyncGetSigningKeyFunction","promisify","getSigningKey","key","error","getHeaderFromToken","token","decodedToken","decode","complete","header","verifyIdToken","clientId","kid","alg","algorithm","ONE_HOUR_IN_MS","jwtClaims","facebookKey","signingKey","publicKey","rsaPublicKey","verify","algorithms","audience","exception","message","iss","sub","validateAuthData","validateAppId","path","get","module","exports"],"mappings":"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","sourcesContent":["// Helper functions for accessing the Facebook Graph API.\nconst Parse = require('parse/node').Parse;\nconst crypto = require('crypto');\nconst jwksClient = require('jwks-rsa');\nconst util = require('util');\nconst jwt = require('jsonwebtoken');\nconst httpsRequest = require('./httpsRequest');\n\nconst TOKEN_ISSUER = 'https://facebook.com';\n\nfunction getAppSecretPath(authData, options = {}) {\n  const appSecret = options.appSecret;\n  if (!appSecret) {\n    return '';\n  }\n  const appsecret_proof = crypto\n    .createHmac('sha256', appSecret)\n    .update(authData.access_token)\n    .digest('hex');\n\n  return `&appsecret_proof=${appsecret_proof}`;\n}\n\nfunction validateGraphToken(authData, options) {\n  return graphRequest(\n    'me?fields=id&access_token=' + authData.access_token + getAppSecretPath(authData, options)\n  ).then(data => {\n    if ((data && data.id == authData.id) || (process.env.TESTING && authData.id === 'test')) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');\n  });\n}\n\nfunction validateGraphAppId(appIds, authData, options) {\n  var access_token = authData.access_token;\n  if (process.env.TESTING && access_token === 'test') {\n    return Promise.resolve();\n  }\n  if (!appIds.length) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is not configured.');\n  }\n  return graphRequest(\n    'app?access_token=' + access_token + getAppSecretPath(authData, options)\n  ).then(data => {\n    if (data && appIds.indexOf(data.id) != -1) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');\n  });\n}\n\nconst getFacebookKeyByKeyId = async (keyId, cacheMaxEntries, cacheMaxAge) => {\n  const client = jwksClient({\n    jwksUri: `${TOKEN_ISSUER}/.well-known/oauth/openid/jwks/`,\n    cache: true,\n    cacheMaxEntries,\n    cacheMaxAge,\n  });\n\n  const asyncGetSigningKeyFunction = util.promisify(client.getSigningKey);\n\n  let key;\n  try {\n    key = await asyncGetSigningKeyFunction(keyId);\n  } catch (error) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Unable to find matching key for Key ID: ${keyId}`\n    );\n  }\n  return key;\n};\n\nconst getHeaderFromToken = token => {\n  const decodedToken = jwt.decode(token, { complete: true });\n  if (!decodedToken) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'provided token does not decode as JWT');\n  }\n\n  return decodedToken.header;\n};\n\nconst verifyIdToken = async ({ token, id }, { clientId, cacheMaxEntries, cacheMaxAge }) => {\n  if (!token) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'id token is invalid for this user.');\n  }\n\n  const { kid: keyId, alg: algorithm } = getHeaderFromToken(token);\n  const ONE_HOUR_IN_MS = 3600000;\n  let jwtClaims;\n\n  cacheMaxAge = cacheMaxAge || ONE_HOUR_IN_MS;\n  cacheMaxEntries = cacheMaxEntries || 5;\n\n  const facebookKey = await getFacebookKeyByKeyId(keyId, cacheMaxEntries, cacheMaxAge);\n  const signingKey = facebookKey.publicKey || facebookKey.rsaPublicKey;\n\n  try {\n    jwtClaims = jwt.verify(token, signingKey, {\n      algorithms: algorithm,\n      // the audience can be checked against a string, a regular expression or a list of strings and/or regular expressions.\n      audience: clientId,\n    });\n  } catch (exception) {\n    const message = exception.message;\n\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `${message}`);\n  }\n\n  if (jwtClaims.iss !== TOKEN_ISSUER) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `id token not issued by correct OpenID provider - expected: ${TOKEN_ISSUER} | from: ${jwtClaims.iss}`\n    );\n  }\n\n  if (jwtClaims.sub !== id) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'auth data is invalid for this user.');\n  }\n  return jwtClaims;\n};\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData, options) {\n  if (authData.token) {\n    return verifyIdToken(authData, options);\n  } else {\n    return validateGraphToken(authData, options);\n  }\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId(appIds, authData, options) {\n  if (authData.token) {\n    return Promise.resolve();\n  } else {\n    return validateGraphAppId(appIds, authData, options);\n  }\n}\n\n// A promisey wrapper for FB graph requests.\nfunction graphRequest(path) {\n  return httpsRequest.get('https://graph.facebook.com/' + path);\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData,\n};\n"]}